generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id                      Int                      @id @default(autoincrement())
  email                   String?                  @unique
  emailVerified           Boolean                  @default(false)
  name                    String?
  ethereumAddress         String?                  @unique
  orcidId                 String?                  @unique
  githubHandle            String?                  @unique
  bitbucketHandle         String?                  @unique
  gitlabHandle            String?                  @unique
  onboarded               Boolean                  @default(false)
  createdAt               DateTime                 @default(now())
  updatedAt               DateTime                 @updatedAt
  bannedTill              DateTime?
  lastPaymentAmount       Decimal?
  shareInGDP              Float?
  kycStatus               String?
  kycVerifiedAt           DateTime?
  kycRejectedAt           DateTime?
  kycRejectionReason      String?
  kycData                 String?
  issuingState            String?
  personalNumber          String?
  emailVerificationTokens EmailVerificationToken[]
  gasTokenDistributions   GasTokenDistribution[]
  openaiLogs              OpenAILog[]
  sessions                Session[]

  @@index([onboarded])
  @@index([onboarded, shareInGDP(sort: Desc)])
  @@index([shareInGDP])
  @@index([kycStatus])
  @@unique([issuingState, personalNumber])
  @@map("users")
}

model Session {
  id        String   @id @default(cuid())
  userId    Int
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@map("sessions")
}

model Batches {
  id            Int            @id @default(autoincrement())
  createdAt     DateTime       @default(now())
  taskId        Int
  batchMappings BatchMapping[]
  task          Task           @relation(fields: [taskId], references: [id], onDelete: Cascade)

  @@map("batches")
}

model BatchMapping {
  id        Int      @id @default(autoincrement())
  customId  String   @unique
  batchId   Int
  createdAt DateTime @default(now())
  batch     Batches  @relation(fields: [batchId], references: [id], onDelete: Cascade)

  @@map("batch_mappings")
}

model NonBatches {
  id               Int               @id @default(autoincrement())
  createdAt        DateTime          @default(now())
  taskId           Int
  nonbatchMappings NonBatchMapping[]
  task             Task              @relation(fields: [taskId], references: [id], onDelete: Cascade)

  @@map("non_batches")
}

model NonBatchMapping {
  id         Int        @id @default(autoincrement())
  customId   String     @unique
  response   String
  nonBatchId Int
  createdAt  DateTime   @default(now())
  batch      NonBatches @relation(fields: [nonBatchId], references: [id], onDelete: Cascade)

  @@map("non_batch_mappings")
}

model Task {
  id              Int              @id @default(autoincrement())
  status          String           @default("NOT_STARTED")
  runnerClassName String
  runnerData      String?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  completedAt     DateTime?
  storeId         String?
  lockTime        DateTime?
  Batches         Batches[]
  NonBatches      NonBatches[]
  openaiLogs      OpenAILog[]
  dependents      TaskDependency[] @relation("TaskDependents")
  dependencies    TaskDependency[] @relation("TaskDependencies")

  @@index([status])
  @@index([runnerClassName])
  @@index([completedAt])
  @@index([lockTime])
  @@map("tasks")
}

model TaskDependency {
  id           Int  @id @default(autoincrement())
  taskId       Int
  dependencyId Int
  dependency   Task @relation("TaskDependents", fields: [dependencyId], references: [id], onDelete: Cascade)
  task         Task @relation("TaskDependencies", fields: [taskId], references: [id], onDelete: Cascade)

  @@unique([taskId, dependencyId])
  @@map("task_dependencies")
}

model OpenAILog {
  id               Int       @id @default(autoincrement())
  userId           Int?
  taskId           Int?
  customId         String    @unique
  storeId          String
  runnerClassName  String
  requestInitiated DateTime  @default(now())
  responseReceived DateTime?
  requestData      String
  responseData     String?
  errorMessage     String?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  user             User?     @relation(fields: [userId], references: [id])
  task             Task?     @relation(fields: [taskId], references: [id])

  @@index([userId])
  @@index([taskId])
  @@index([runnerClassName])
  @@index([createdAt])
  @@index([storeId])
  @@map("openai_logs")
}

model Global {
  id        Int      @id @default(autoincrement())
  worldGdp  Float?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("global")
}

model GasTokenDistribution {
  id               Int      @id @default(autoincrement())
  userId           Int
  network          String   // Network identifier (e.g., 'mainnet', 'polygon', 'arbitrum')
  amount           Decimal
  amountUsd        Decimal
  distributionDate DateTime @default(now())
  status           String   @default("PENDING")
  transactionHash  String?
  errorMessage     String?
  tokenType        String   @default("NATIVE") // NATIVE or ERC20
  tokenSymbol      String   @default("ETH")
  tokenAddress     String?
  tokenDecimals    Int      @default(18)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([network])
  @@index([status])
  @@index([distributionDate])
  @@index([network, tokenSymbol])
  @@unique([userId, network, tokenSymbol, distributionDate]) // Prevent duplicate distributions per network/token per day
  @@map("gas_token_distributions")
}

model GasTokenReserve {
  id               Int      @id @default(autoincrement())
  network          String   // Network identifier (e.g., 'mainnet', 'polygon', 'arbitrum')
  totalReserve     Decimal  @default(0)
  lastDistribution DateTime @default(now())
  tokenType        String   @default("NATIVE") // NATIVE or ERC20
  tokenSymbol      String   @default("ETH")
  tokenAddress     String?
  tokenDecimals    Int      @default(18)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@unique([network, tokenSymbol, tokenType]) // One reserve per network/token
  @@map("gas_token_reserves")
}

model EmailVerificationToken {
  id        String   @id @default(cuid())
  token     String   @unique
  email     String
  userId    Int
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@index([used])
  @@map("email_verification_tokens")
}
